#Licensed under Apache 2.0 License.
#Â© 2020 Battelle Energy Alliance, LLC
#ALL RIGHTS RESERVED
#.
#Prepared by Battelle Energy Alliance, LLC
#Under Contract No. DE-AC07-05ID14517
#With the U. S. Department of Energy
#.
#NOTICE:  This computer software was prepared by Battelle Energy
#Alliance, LLC, hereinafter the Contractor, under Contract
#No. AC07-05ID14517 with the United States (U. S.) Department of
#Energy (DOE).  The Government is granted for itself and others acting on
#its behalf a nonexclusive, paid-up, irrevocable worldwide license in this
#data to reproduce, prepare derivative works, and perform publicly and
#display publicly, by or on behalf of the Government. There is provision for
#the possible extension of the term of this license.  Subsequent to that
#period or any extension granted, the Government is granted for itself and
#others acting on its behalf a nonexclusive, paid-up, irrevocable worldwide
#license in this data to reproduce, prepare derivative works, distribute
#copies to the public, perform publicly and display publicly, and to permit
#others to do so.  The specific term of the license can be identified by
#inquiry made to Contractor or DOE.  NEITHER THE UNITED STATES NOR THE UNITED
#STATES DEPARTMENT OF ENERGY, NOR CONTRACTOR MAKES ANY WARRANTY, EXPRESS OR
#IMPLIED, OR ASSUMES ANY LIABILITY OR RESPONSIBILITY FOR THE USE, ACCURACY,
#COMPLETENESS, OR USEFULNESS OR ANY INFORMATION, APPARATUS, PRODUCT, OR
#PROCESS DISCLOSED, OR REPRESENTS THAT ITS USE WOULD NOT INFRINGE PRIVATELY
#OWNED RIGHTS.
import os
import math
import scipy.io
import numpy as np
np.seterr(divide='ignore')
def find_nearest(array, value):
  """
    Find element in array nearest  to value
    @ In, array, numpy array
    @ In, value, the value
    @ Out, idx, int, index
    @ Out, diff[indx], flaat, the diff
  """
  array = np.asarray(array)
  diff =  np.abs(array - value)
  idx = (diff).argmin()
  return idx, diff[idx]

def find_nearest_array(array, array_comparison, tol = 1e-4):
  """
    Find nearest array
    @ In, array, array-like, the array to compare from
    @ In, array_comparison, array-like, the array to compare to
    @ In, tol, float, the tolerance
    @ Out, indices, array, contains booleans of indexes of array within tolerance
    @ Out, np.any(notFound), boolean, returns true if all array points are within tolerance
  """
  array_comparison = np.asarray(array_comparison)
  indices = np.zeros(len(array), dtype=bool)
  notFound =  np.zeros(len(array), dtype=bool)
  for val in array_comparison:
    idx, diff = find_nearest(array, val)
    rel = (np.abs(diff / val)) if val != 0 else np.abs(val)
    if rel <= tol:
      indices[idx] = True
    else:
      notFound[idx] = True
  return indices, not np.any(notFound)

class Variable:
  '''
  Stores the information about each variable in the test and gold.
  '''
  def __init__(self, name, descr, timeSeries, isparam):
    self.name = name
    self.descr = descr
    self.isparam = isparam
    self.timeSeries = timeSeries
    self.timeSeries[np.isinf(self.timeSeries) | np.isnan(self.timeSeries)] = 0
    self.compVals = None
    self.accept = None
    
class DymolaMatDiffer:
  """
    Used for comparing mat files generated by Dymola
  """ 
 
  def __init__(self, testDir, outFile, **kwargs):
    """
      Create a DymolaMatDiffer class
      @ In, testDir, string, the directory where the test takes place
      @ In, outFile, string, the files to be compared.  They will be in testDir + outFile
      and testDir + gold + outFile
      @ In, kwargs, other arguments that may be included:
      - 'comment': indicates the character or string that should be used to denote a comment line
      @ Out, None
    """
    self._outFile = outFile
    self._message = ""
    self._same = True
    self.tols = {'maxDiff': float(kwargs.get('relTol',1e-3))}
    self._out_step = float(kwargs.get('outputStep',None))
    self._stop_time = float(kwargs.get('stopTime',None))
    self.testDir = testDir
    self._goldDir = os.path.join(self.testDir, "gold")
    self._goldFiles = os.listdir(self._goldDir)
    self.testVars = {}
    self.goldVars = {}
    self.variablesToLoad = []
    self.timeSteps = None
    self.timeStepsGold = None
    self.timeStepsArray, self.timeStepsArraygold = None, None
    self.commonVars = {}
    self.differVars = set()
    self.loaded = True
    self.sameVariables = True
    self.timeLoaded = False

  # Should be used to compare the gold file and the test file
  def load(self, isTest, file):
    '''
      Used to load the mat files in.
      Checks the file structure is correct.
      @ In, isTest, bool, True if loading in test, False for reference
      @ In, file, string, the path of the mat file
      @ Out, None
    '''
    # Define the functions that extract strings from the matrix:
    #  - strMatNormal: for parallel string
    #  - strMatTrans:  for vertical string
    # These functions join the strings together, resulting in one string in each row, and remove
    #   trailing whitespace.
    strMatNormal = lambda a: [''.join(s).rstrip() for s in a]
    strMatTrans = lambda a: [''.join(s).rstrip() for s in zip(*a)]
    # Define the function that returns '1.0' with the sign of 'x'
    sign = lambda x: math.copysign(1.0, x)
    #File Variables
    # Load the .mat file, check that file structure is supported
    mat = scipy.io.loadmat(file, chars_as_strings=False)
    if isTest:
      # Check the structure of the output file.
      try:
        fileInfo = strMatNormal(mat['Aclass'])
      except KeyError:
        self._same = False
        self._message = 'File structure not supported!'
        self.loaded = False
        return
      # Check the version of the output file (version 1.1).
      if fileInfo[1] != '1.1' or fileInfo[3] != 'binTrans':
        self._same = False
        self._message = 'File structure not supported!'
        self.loaded = False
        return
    timeSteps = mat['data_2'][0]
    if isTest:
      self.timeSteps = timeSteps
    else:
      self.timeStepsGold = timeSteps
    numOutputPts = timeSteps.shape[0]
    names = strMatTrans(mat['name'])  # names
    descr = strMatTrans(mat['description'])  # descriptions
    for i in range(len(names)):
      d = mat['dataInfo'][0][i]  # data block
      x = mat['dataInfo'][1][i]  # column (original)
      c = abs(x) - 1  # column (reduced)
      s = sign(x)  # sign
      if c:
        if not (len(self.variablesToLoad) > 0 and names[i] not in self.variablesToLoad):
          dataValue = mat['data_%d' % d][c]
          if float(s) < 0:
            dataValue = dataValue * -1.0
          if d == 1:
            if isTest:
              self.testVars[names[i]] = Variable(names[i], descr[i], np.full(shape=numOutputPts, fill_value=dataValue[0], dtype=np.float64), True)
            else:
              self.goldVars[names[i]] = Variable(names[i], descr[i], np.full(shape=numOutputPts, fill_value=dataValue[0], dtype=np.float64), True)
          elif d == 2:
            if isTest:
              self.testVars[names[i]] = Variable(names[i], descr[i], dataValue.astype(np.float64), False)
            else:
              self.goldVars[names[i]] = Variable(names[i], descr[i], dataValue.astype(np.float64), False)
          else:
            self._same = False
            self._message = 'File structure not supported!'
            return
    
  def setTimes(self):
    '''
      Checks that  all time steps are found and creates time arrays
      @ In, None
      @ Out, None
    '''
    if self._stop_time and self._out_step:
      numComparisonPts = int(self._stop_time/self._out_step)+ 1
      comparisonTimeGrid = np.linspace(self.timeStepsGold[0], self.timeStepsGold[-1], num=numComparisonPts, endpoint=True)
      indicesSim, allFound = find_nearest_array(self.timeSteps, comparisonTimeGrid, tol=self.tols['maxDiff'])
      indicesGold, allFoundGold = find_nearest_array(self.timeStepsGold, comparisonTimeGrid, tol=self.tols['maxDiff'])
      if not allFound or not allFoundGold:
        comparisonSteps = 'Comparison Time Steps:\n'
        for tm in comparisonTimeGrid:
          comparisonSteps += str(tm) + '\n'
        if not allFound:
          self._message = 'Not all the time steps have been found in the simulation file. Check the input of the model.\n'
          self._message += 'Simulation Time Steps:\n'
          for tm in self.timeSteps:
            self._message += str(tm) + '\n'
          self._message += comparisonSteps
          self._same = False
        else:
          self._message = 'Not all the time steps have been found in the gold file. Check the input of the model.\n'
          self._message += 'Gold Time Steps:\n'
          for tm in self.timeStepsGold:
            self._message += str(tm) + '\n'
          self._message += comparisonSteps
          self._same = False
        self.timeLoaded = False
        return
      else:
        self.timeLoaded = True
    if not self._out_step:
      self.timeStepsArray, self.timeStepsArraygold = np.array([self.timeSteps]),  np.array([self.timeStepsgold])
    else:
      self.timeStepsArray, self.timeStepsArraygold = np.array([comparisonTimeGrid]),  np.array([comparisonTimeGrid])
        
  def compareVariables(self):
    '''
      Checks the number of variables are the same. If the number of variables are the same,
      checks the variable names are the same. Stores list of common variables.
      @ In, None
      @ Out, None
    '''
    testSet = set(self.testVars.keys())
    goldSet = set(self.goldVars.keys())
    self.commonVars = testSet.intersection(goldSet)
    goldOnly = goldSet - testSet
    testOnly = testSet - goldSet
    if len(testSet) != len(goldSet):
      self._same = False
      self._message = 'Shapes of the Values do not match!'
      self.sameVariables = False
    elif len(goldOnly) or len(testOnly):
      self.sameVariables = False
      self._same = False
      self._message = 'Variable Names are different. Variables not present in test file are: \n'
      if len(goldOnly):
        self._message += ' '.join(sorted(goldOnly))
      if len(testOnly):
        self._message += 'Variable not present in the reference file are: \n'
        self._message += ' '.join(sorted(testOnly))
    for var in goldOnly:
      del self.goldVars[var]
    for var in self.commonVars:
      self.goldVars[var].compVals = {}
                
  def maxDiff(self, var):
    '''
      Comparision function that calculates and stores the maximum relative
      difference between the test and reference file variable.
      @ In, var, string, name of variable to compare
      @ Out, None
    '''
    with np.errstate(divide='ignore', invalid='ignore'):
      if not self.testVars[var].isparam:
        maxDiff = np.divide(abs(self.testVars[var].timeSeries - self.goldVars[var].timeSeries),  abs(self.goldVars[var].timeSeries))
        maxDiff = max(maxDiff)
      else:
        maxDiff = np.divide(abs(self.testVars[var].timeSeries[0] -  self.goldVars[var].timeSeries[0]), abs(self.goldVars[var].timeSeries[0]))
    self.goldVars[var].compVals['maxDiff'] = maxDiff
               
  def computeComparisons(self):
    '''
      Calls all the comparison functions.
      @ In, None
      @ Out, None
    '''
    for var in self.commonVars:
      self.maxDiff(var)
    
  def checkMaxDiff(self):
    '''
      Check if the maximum relative difference is within the set tolerance.
      @ In, None
      @ Out, differ, set, contains all variables that do not meet max relative
      difference tolerance criteria.
    '''
    differ = set()
    for var in self.commonVars:
      self.goldVars[var].compVals['maxDiff']
      if self.goldVars[var].compVals['maxDiff'] > self.tols['maxDiff']:
        differ.add(var)
    return differ
            
  def checkTol(self):
    '''
      Calls the tolerance functions for each comparion applied.
      Sets same, message variables accordingly.
      @ In, None
      @ Out, None
    '''
    self.differVars.clear()
    self.differVars = self.checkMaxDiff()
    if len(self.differVars):
      self._same = False
      res = '\nMax_Rel_Diff  Variable\n'
      messageInfo = []
      for var in sorted(self.differVars):
        messageInfo.append((self.goldVars[var].compVals['maxDiff'], var))
      res += "\n".join("{:.10f}  {}".format(x, y) for x, y in messageInfo)
      self._message = 'Variable Values are different. Variables that are different (with their max relative difference, respectively) are \n'
      self._message += res
      
  def diff(self):
    '''
      Compares the test file with the reference files.
      Loops over all reference files in gold folder.
      @ In, None
      @ Out, self._same, bool, whether the test matches with any of the reference files
      @ Out, self._message, string, message to show if files do not match
    '''
    self.load(isTest = True, file = os.path.join(self.testDir, self._outFile))
    if not self._same:
      return (self._same, self._message)
    goldFiles = os.listdir(self._goldDir)
    goldFiles = list(filter(lambda x: '.mat' in x, goldFiles))
    passedSetTimes= []
    for goldFile in goldFiles: #loops over all reference files in gold folder
      self._same, self._message = True, ''
      self.load(isTest = False, file = os.path.join(self._goldDir, goldFile))
      if not self._same:
        continue
      self.setTimes()
      if not self._same and goldFile == goldFiles[-1]:
        if len(passedSetTimes):
          self._same, self._message = True, ''
          goldFile = passedSetTimes[-1]
          self.load(isTest=False, file=os.path.join(self._goldDir, goldFile))
          self.setTimes()
          self.compareVariables()
          if not self._same:
            return self._same, self._message
          self.computeComparisons()
          self.checkTol()
          if not self._same:
            return self._same, self._message
        else:
          continue
      elif not self._same:
        continue
      else:
        passedSetTimes.append(goldFile)
      self.compareVariables()
      if not self._same:
        continue
      self.computeComparisons()
      self.checkTol()
      if self._same:
        return (self._same, self._message)
    return (self._same, self._message)
        
  








